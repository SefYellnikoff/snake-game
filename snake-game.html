<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Snake</title>
    <style>
        :root {
            color-scheme: dark;
        }

        body {
            margin: 0;
            min-height: 100vh;
            display: grid;
            place-items: center;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            background: #0b1020;
            color: #e8eefc;
        }

        .wrap {
            display: grid;
            gap: 12px;
            justify-items: center;
            padding: 18px;
        }

        canvas {
            border-radius: 16px;
            background: #0a0f1e;
            box-shadow: 0 12px 30px rgba(0, 0, 0, .45);
            border: 1px solid rgba(255, 255, 255, .08);
            image-rendering: pixelated;
        }

        .hud {
            width: min(520px, 92vw);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            opacity: .95;
        }

        .pill {
            padding: 8px 12px;
            border-radius: 999px;
            background: rgba(255, 255, 255, .06);
            border: 1px solid rgba(255, 255, 255, .08);
        }

        .help {
            font-size: 12px;
            opacity: .85;
            text-align: center;
            line-height: 1.4;
        }

        .btns {
            display: flex;
            gap: 8px;
        }

        button {
            cursor: pointer;
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(255, 255, 255, .06);
            color: inherit;
        }

        button:hover {
            background: rgba(255, 255, 255, .10);
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="hud">
            <div class="pill" id="score">Score: 0</div>
            <div class="btns">
                <button id="pauseBtn" type="button">Pause (Space)</button>
                <button id="restartBtn" type="button">Restart (R)</button>
            </div>
        </div>

        <canvas id="game" width="520" height="520" aria-label="Snake game"></canvas>

        <div class="help">
            Move: <b>Arrow Keys</b> / <b>WASD</b> · Pause: <b>Space</b> · Restart: <b>R</b><br />
            Tip: You can’t instantly reverse direction.
        </div>
    </div>

    <script>
        (() => {
            const canvas = document.getElementById("game");
            const ctx = canvas.getContext("2d");

            // Grid settings
            const CELL = 20;            // cell size in pixels
            const GRID = canvas.width / CELL; // 26 if width is 520
            const TICK_MS_BASE = 110;   // base speed; lower = faster

            // HUD
            const scoreEl = document.getElementById("score");
            const pauseBtn = document.getElementById("pauseBtn");
            const restartBtn = document.getElementById("restartBtn");

            // Game state
            let snake, dir, nextDir, food, score, paused, gameOver;
            let tickMs, acc, lastTime;

            function randCell() {
                return { x: Math.floor(Math.random() * GRID), y: Math.floor(Math.random() * GRID) };
            }

            function cellKey(c) { return `${c.x},${c.y}`; }

            function reset() {
                const start = { x: Math.floor(GRID / 2), y: Math.floor(GRID / 2) };
                snake = [start, { x: start.x - 1, y: start.y }, { x: start.x - 2, y: start.y }];
                dir = { x: 1, y: 0 };
                nextDir = { x: 1, y: 0 };
                score = 0;
                paused = false;
                gameOver = false;
                tickMs = TICK_MS_BASE;
                acc = 0;
                lastTime = performance.now();
                placeFood();
                updateHUD();
                draw(); // draw immediately
            }

            function updateHUD() {
                scoreEl.textContent = `Score: ${score}${gameOver ? " — Game Over" : paused ? " — Paused" : ""}`;
                pauseBtn.textContent = paused ? "Resume (Space)" : "Pause (Space)";
            }

            function placeFood() {
                const occupied = new Set(snake.map(cellKey));
                let f = randCell();
                while (occupied.has(cellKey(f))) f = randCell();
                food = f;
            }

            function isOpposite(a, b) {
                return a.x === -b.x && a.y === -b.y;
            }

            function setDirection(newDir) {
                if (gameOver) return;
                // prevent reversing into itself
                if (!isOpposite(newDir, dir)) nextDir = newDir;
            }

            function step() {
                if (paused || gameOver) return;

                dir = nextDir;

                const head = snake[0];
                const newHead = { x: head.x + dir.x, y: head.y + dir.y };

                // Wall collision
                if (newHead.x < 0 || newHead.x >= GRID || newHead.y < 0 || newHead.y >= GRID) {
                    gameOver = true;
                    updateHUD();
                    return;
                }

                // Self collision (check against body)
                for (let i = 0; i < snake.length; i++) {
                    if (snake[i].x === newHead.x && snake[i].y === newHead.y) {
                        gameOver = true;
                        updateHUD();
                        return;
                    }
                }

                snake.unshift(newHead);

                // Food?
                if (newHead.x === food.x && newHead.y === food.y) {
                    score += 1;
                    // Speed up a bit every few points (but cap)
                    tickMs = Math.max(55, TICK_MS_BASE - Math.floor(score / 4) * 6);
                    placeFood();
                } else {
                    snake.pop();
                }

                updateHUD();
            }

            function drawGrid() {
                // subtle grid dots
                ctx.save();
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = "#a9b7ff";
                for (let y = 0; y < GRID; y++) {
                    for (let x = 0; x < GRID; x++) {
                        if ((x + y) % 2 === 0) {
                            ctx.fillRect(x * CELL + CELL / 2, y * CELL + CELL / 2, 1, 1);
                        }
                    }
                }
                ctx.restore();
            }

            function draw() {
                // background
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#0a0f1e";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                drawGrid();

                // food
                ctx.save();
                ctx.fillStyle = "#ff5c7a";
                const fx = food.x * CELL, fy = food.y * CELL;
                roundRect(ctx, fx + 3, fy + 3, CELL - 6, CELL - 6, 6);
                ctx.fill();
                ctx.restore();

                // snake
                for (let i = snake.length - 1; i >= 0; i--) {
                    const s = snake[i];
                    const x = s.x * CELL, y = s.y * CELL;

                    if (i === 0) {
                        // head
                        ctx.fillStyle = "#76f6a6";
                        roundRect(ctx, x + 2, y + 2, CELL - 4, CELL - 4, 8);
                        ctx.fill();

                        // tiny "eyes" based on direction
                        ctx.fillStyle = "rgba(0,0,0,.35)";
                        const ex = dir.x === 1 ? x + CELL - 7 : dir.x === -1 ? x + 5 : x + CELL / 2 - 1;
                        const ey = dir.y === 1 ? y + CELL - 7 : dir.y === -1 ? y + 5 : y + CELL / 2 - 1;
                        ctx.fillRect(ex, ey, 2, 2);
                        ctx.fillRect(ex + (dir.y !== 0 ? 6 : 0), ey + (dir.x !== 0 ? 6 : 0), 2, 2);
                    } else {
                        // body gradient-ish by index
                        const t = i / snake.length;
                        ctx.fillStyle = `rgba(118, 246, 166, ${0.25 + (1 - t) * 0.55})`;
                        roundRect(ctx, x + 3, y + 3, CELL - 6, CELL - 6, 7);
                        ctx.fill();
                    }
                }

                // overlays
                if (paused || gameOver) {
                    ctx.save();
                    ctx.fillStyle = "rgba(0,0,0,.45)";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = "#e8eefc";
                    ctx.textAlign = "center";
                    ctx.font = "bold 28px system-ui, sans-serif";
                    ctx.fillText(gameOver ? "Game Over" : "Paused", canvas.width / 2, canvas.height / 2 - 10);
                    ctx.font = "14px system-ui, sans-serif";
                    ctx.fillText("Press Space to toggle pause · Press R to restart", canvas.width / 2, canvas.height / 2 + 20);
                    ctx.restore();
                }
            }

            function loop(now) {
                const dt = now - lastTime;
                lastTime = now;
                acc += dt;

                while (acc >= tickMs) {
                    step();
                    acc -= tickMs;
                }

                draw();
                requestAnimationFrame(loop);
            }

            function roundRect(ctx, x, y, w, h, r) {
                const rr = Math.min(r, w / 2, h / 2);
                ctx.beginPath();
                ctx.moveTo(x + rr, y);
                ctx.arcTo(x + w, y, x + w, y + h, rr);
                ctx.arcTo(x + w, y + h, x, y + h, rr);
                ctx.arcTo(x, y + h, x, y, rr);
                ctx.arcTo(x, y, x + w, y, rr);
                ctx.closePath();
            }

            function togglePause() {
                if (gameOver) return;
                paused = !paused;
                updateHUD();
            }

            // Input
            window.addEventListener("keydown", (e) => {
                const k = e.key.toLowerCase();

                if (k === " " || k === "spacebar") {
                    e.preventDefault();
                    togglePause();
                    return;
                }
                if (k === "r") { reset(); return; }

                // arrows + wasd
                if (k === "arrowup" || k === "w") setDirection({ x: 0, y: -1 });
                else if (k === "arrowdown" || k === "s") setDirection({ x: 0, y: 1 });
                else if (k === "arrowleft" || k === "a") setDirection({ x: -1, y: 0 });
                else if (k === "arrowright" || k === "d") setDirection({ x: 1, y: 0 });
            });

            pauseBtn.addEventListener("click", togglePause);
            restartBtn.addEventListener("click", reset);

            reset();
            requestAnimationFrame(loop);
        })();
    </script>
</body>

</html>